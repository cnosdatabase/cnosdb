// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod models {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FIELD_TYPE: i32 = -1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FIELD_TYPE: i32 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FIELD_TYPE: [FieldType; 6] = [
        FieldType::Unknown,
        FieldType::Float,
        FieldType::Integer,
        FieldType::Unsigned,
        FieldType::Boolean,
        FieldType::String,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FieldType(pub i32);
    #[allow(non_upper_case_globals)]
    impl FieldType {
        pub const Unknown: Self = Self(-1);
        pub const Float: Self = Self(0);
        pub const Integer: Self = Self(1);
        pub const Unsigned: Self = Self(2);
        pub const Boolean: Self = Self(3);
        pub const String: Self = Self(4);

        pub const ENUM_MIN: i32 = -1;
        pub const ENUM_MAX: i32 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Unknown,
            Self::Float,
            Self::Integer,
            Self::Unsigned,
            Self::Boolean,
            Self::String,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Float => Some("Float"),
                Self::Integer => Some("Integer"),
                Self::Unsigned => Some("Unsigned"),
                Self::Boolean => Some("Boolean"),
                Self::String => Some("String"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for FieldType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FieldType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for FieldType {
        type Output = FieldType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            unsafe {
                flatbuffers::emplace_scalar::<i32>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for FieldType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i32::to_le(self.0);
            Self(b)
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(self) -> Self {
            let b = i32::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FieldType {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FieldType {}
    // struct RowKey, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct RowKey(pub [u8; 16]);
    impl Default for RowKey {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl std::fmt::Debug for RowKey {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("RowKey")
                .field("series_id", &self.series_id())
                .field("timestamp", &self.timestamp())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RowKey {}
    impl flatbuffers::SafeSliceAccess for RowKey {}
    impl<'a> flatbuffers::Follow<'a> for RowKey {
        type Inner = &'a RowKey;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a RowKey>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a RowKey {
        type Inner = &'a RowKey;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<RowKey>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for RowKey {
        type Output = RowKey;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe { ::std::slice::from_raw_parts(self as *const RowKey as *const u8, Self::size()) };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b RowKey {
        type Output = RowKey;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe { ::std::slice::from_raw_parts(*self as *const RowKey as *const u8, Self::size()) };
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for RowKey {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> RowKey {
        #[allow(clippy::too_many_arguments)]
        pub fn new(series_id: u64, timestamp: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_series_id(series_id);
            s.set_timestamp(timestamp);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.RowKey"
        }

        pub fn series_id(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<u64>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<u64>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_series_id(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const u64 as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<u64>(),
                );
            }
        }

        pub fn timestamp(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<u64>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<u64>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_timestamp(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const u64 as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<u64>(),
                );
            }
        }
    }

    // struct ColumnKey, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ColumnKey(pub [u8; 16]);
    impl Default for ColumnKey {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl std::fmt::Debug for ColumnKey {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("ColumnKey")
                .field("series_id", &self.series_id())
                .field("field_id", &self.field_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ColumnKey {}
    impl flatbuffers::SafeSliceAccess for ColumnKey {}
    impl<'a> flatbuffers::Follow<'a> for ColumnKey {
        type Inner = &'a ColumnKey;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ColumnKey>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ColumnKey {
        type Inner = &'a ColumnKey;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ColumnKey>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ColumnKey {
        type Output = ColumnKey;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe { ::std::slice::from_raw_parts(self as *const ColumnKey as *const u8, Self::size()) };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b ColumnKey {
        type Output = ColumnKey;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe { ::std::slice::from_raw_parts(*self as *const ColumnKey as *const u8, Self::size()) };
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for ColumnKey {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ColumnKey {
        #[allow(clippy::too_many_arguments)]
        pub fn new(series_id: u64, field_id: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_series_id(series_id);
            s.set_field_id(field_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.ColumnKey"
        }

        pub fn series_id(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<u64>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<u64>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_series_id(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const u64 as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<u64>(),
                );
            }
        }

        pub fn field_id(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<u64>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<u64>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_field_id(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const u64 as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<u64>(),
                );
            }
        }
    }

    pub enum PingBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PingBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PingBody<'a> {
        type Inner = PingBody<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> PingBody<'a> {
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.PingBody"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PingBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PingBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<PingBody<'bldr>> {
            let mut builder = PingBodyBuilder::new(_fbb);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn payload(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PingBody::VT_PAYLOAD, None)
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for PingBody<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PingBodyArgs<'a> {
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PingBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PingBodyArgs { payload: None }
        }
    }

    pub struct PingBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PingBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PingBody::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PingBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PingBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PingBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for PingBody<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("PingBody");
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    pub enum RowFieldOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RowField<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RowField<'a> {
        type Inner = RowField<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> RowField<'a> {
        pub const VT_FIELD_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.RowField"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RowField { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RowFieldArgs<'args>,
        ) -> flatbuffers::WIPOffset<RowField<'bldr>> {
            let mut builder = RowFieldBuilder::new(_fbb);
            builder.add_field_id(args.field_id);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn field_id(&self) -> u64 {
            self._tab.get::<u64>(RowField::VT_FIELD_ID, Some(0)).unwrap()
        }
        #[inline]
        pub fn type_(&self) -> FieldType {
            self._tab
                .get::<FieldType>(RowField::VT_TYPE_, Some(FieldType::Float))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RowField::VT_VALUE, None)
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for RowField<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("field_id", Self::VT_FIELD_ID, false)?
                .visit_field::<FieldType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RowFieldArgs<'a> {
        pub field_id: u64,
        pub type_: FieldType,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for RowFieldArgs<'a> {
        #[inline]
        fn default() -> Self {
            RowFieldArgs {
                field_id: 0,
                type_: FieldType::Float,
                value: None,
            }
        }
    }

    pub struct RowFieldBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RowFieldBuilder<'a, 'b> {
        #[inline]
        pub fn add_field_id(&mut self, field_id: u64) {
            self.fbb_.push_slot::<u64>(RowField::VT_FIELD_ID, field_id, 0);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: FieldType) {
            self.fbb_
                .push_slot::<FieldType>(RowField::VT_TYPE_, type_, FieldType::Float);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RowField::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowFieldBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RowFieldBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RowField<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for RowField<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("RowField");
            ds.field("field_id", &self.field_id());
            ds.field("type_", &self.type_());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum RowOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Row<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Row<'a> {
        type Inner = Row<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Row<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_FIELDS: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Row"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Row { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RowArgs<'args>,
        ) -> flatbuffers::WIPOffset<Row<'bldr>> {
            let mut builder = RowBuilder::new(_fbb);
            if let Some(x) = args.fields {
                builder.add_fields(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> Option<&'a RowKey> {
            self._tab.get::<RowKey>(Row::VT_KEY, None)
        }
        #[inline]
        pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RowField<'a>>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RowField>>>>(
                    Row::VT_FIELDS,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for Row<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<RowKey>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RowField>>>>("fields", Self::VT_FIELDS, false)?
     .finish();
            Ok(())
        }
    }
    pub struct RowArgs<'a> {
        pub key: Option<&'a RowKey>,
        pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RowField<'a>>>>>,
    }
    impl<'a> Default for RowArgs<'a> {
        #[inline]
        fn default() -> Self {
            RowArgs {
                key: None,
                fields: None,
            }
        }
    }

    pub struct RowBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RowBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: &RowKey) {
            self.fbb_.push_slot_always::<&RowKey>(Row::VT_KEY, key);
        }
        #[inline]
        pub fn add_fields(
            &mut self,
            fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RowField<'b>>>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Row::VT_FIELDS, fields);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RowBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Row<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Row<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Row");
            ds.field("key", &self.key());
            ds.field("fields", &self.fields());
            ds.finish()
        }
    }
    pub enum RowsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Rows<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Rows<'a> {
        type Inner = Rows<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Rows<'a> {
        pub const VT_ROWS: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Rows"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Rows { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RowsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Rows<'bldr>> {
            let mut builder = RowsBuilder::new(_fbb);
            if let Some(x) = args.rows {
                builder.add_rows(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row>>>>(
                    Rows::VT_ROWS,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for Rows<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Row>>>>("rows", Self::VT_ROWS, false)?
     .finish();
            Ok(())
        }
    }
    pub struct RowsArgs<'a> {
        pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>>>,
    }
    impl<'a> Default for RowsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RowsArgs { rows: None }
        }
    }

    pub struct RowsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RowsBuilder<'a, 'b> {
        #[inline]
        pub fn add_rows(
            &mut self,
            rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Row<'b>>>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Rows::VT_ROWS, rows);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RowsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Rows<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Rows<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Rows");
            ds.field("rows", &self.rows());
            ds.finish()
        }
    }
    pub enum TagOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Tag<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
        type Inner = Tag<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Tag<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Tag"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Tag { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TagArgs<'args>,
        ) -> flatbuffers::WIPOffset<Tag<'bldr>> {
            let mut builder = TagBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Tag::VT_KEY, None)
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn value(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Tag::VT_VALUE, None)
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Tag<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("key", Self::VT_KEY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TagArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for TagArgs<'a> {
        #[inline]
        fn default() -> Self {
            TagArgs { key: None, value: None }
        }
    }

    pub struct TagBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TagBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_KEY, key);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TagBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Tag<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Tag");
            ds.field("key", &self.key());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum FieldOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Field<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Field<'a> {
        type Inner = Field<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Field<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Field"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Field { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FieldArgs<'args>,
        ) -> flatbuffers::WIPOffset<Field<'bldr>> {
            let mut builder = FieldBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.add_type_(args.type_);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Field::VT_NAME, None)
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn type_(&self) -> FieldType {
            self._tab
                .get::<FieldType>(Field::VT_TYPE_, Some(FieldType::Float))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Field::VT_VALUE, None)
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for Field<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("name", Self::VT_NAME, false)?
                .visit_field::<FieldType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FieldArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub type_: FieldType,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for FieldArgs<'a> {
        #[inline]
        fn default() -> Self {
            FieldArgs {
                name: None,
                type_: FieldType::Float,
                value: None,
            }
        }
    }

    pub struct FieldBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: FieldType) {
            self.fbb_
                .push_slot::<FieldType>(Field::VT_TYPE_, type_, FieldType::Float);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FieldBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Field<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Field");
            ds.field("name", &self.name());
            ds.field("type_", &self.type_());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum PointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Point<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Point<'a> {
        type Inner = Point<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Point<'a> {
        pub const VT_DB: flatbuffers::VOffsetT = 4;
        pub const VT_TABLE: flatbuffers::VOffsetT = 6;
        pub const VT_TAGS: flatbuffers::VOffsetT = 8;
        pub const VT_FIELDS: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Point"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Point { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointArgs<'args>,
        ) -> flatbuffers::WIPOffset<Point<'bldr>> {
            let mut builder = PointBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.fields {
                builder.add_fields(x);
            }
            if let Some(x) = args.tags {
                builder.add_tags(x);
            }
            if let Some(x) = args.table {
                builder.add_table(x);
            }
            if let Some(x) = args.db {
                builder.add_db(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn db(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Point::VT_DB, None)
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn table(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Point::VT_TABLE, None)
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag>>>>(
                    Point::VT_TAGS,
                    None,
                )
        }
        #[inline]
        pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field>>>>(
                    Point::VT_FIELDS,
                    None,
                )
        }
        #[inline]
        pub fn timestamp(&self) -> i64 {
            self._tab.get::<i64>(Point::VT_TIMESTAMP, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Point<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("db", Self::VT_DB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("table", Self::VT_TABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tag>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Field>>>>("fields", Self::VT_FIELDS, false)?
     .visit_field::<i64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
            Ok(())
        }
    }
    pub struct PointArgs<'a> {
        pub db: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub table: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>>>,
        pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>>>,
        pub timestamp: i64,
    }
    impl<'a> Default for PointArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointArgs {
                db: None,
                table: None,
                tags: None,
                fields: None,
                timestamp: 0,
            }
        }
    }

    pub struct PointBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointBuilder<'a, 'b> {
        #[inline]
        pub fn add_db(&mut self, db: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_DB, db);
        }
        #[inline]
        pub fn add_table(&mut self, table: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_TABLE, table);
        }
        #[inline]
        pub fn add_tags(
            &mut self,
            tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Tag<'b>>>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_TAGS, tags);
        }
        #[inline]
        pub fn add_fields(
            &mut self,
            fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Field<'b>>>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_FIELDS, fields);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: i64) {
            self.fbb_.push_slot::<i64>(Point::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Point<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Point");
            ds.field("db", &self.db());
            ds.field("table", &self.table());
            ds.field("tags", &self.tags());
            ds.field("fields", &self.fields());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    pub enum PointsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Points<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Points<'a> {
        type Inner = Points<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Points<'a> {
        pub const VT_DATABASE: flatbuffers::VOffsetT = 4;
        pub const VT_POINTS: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Points"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Points { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Points<'bldr>> {
            let mut builder = PointsBuilder::new(_fbb);
            if let Some(x) = args.points {
                builder.add_points(x);
            }
            if let Some(x) = args.database {
                builder.add_database(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn database(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Points::VT_DATABASE, None)
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(
                    Points::VT_POINTS,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for Points<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("database", Self::VT_DATABASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("points", Self::VT_POINTS, false)?
     .finish();
            Ok(())
        }
    }
    pub struct PointsArgs<'a> {
        pub database: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
    }
    impl<'a> Default for PointsArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointsArgs {
                database: None,
                points: None,
            }
        }
    }

    pub struct PointsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointsBuilder<'a, 'b> {
        #[inline]
        pub fn add_database(&mut self, database: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_DATABASE, database);
        }
        #[inline]
        pub fn add_points(
            &mut self,
            points: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Point<'b>>>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_POINTS, points);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Points<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Points<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Points");
            ds.field("database", &self.database());
            ds.field("points", &self.points());
            ds.finish()
        }
    }
    pub enum ColumnKeysOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ColumnKeys<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ColumnKeys<'a> {
        type Inner = ColumnKeys<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ColumnKeys<'a> {
        pub const VT_COLUMN_KEYS: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.ColumnKeys"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ColumnKeys { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ColumnKeysArgs<'args>,
        ) -> flatbuffers::WIPOffset<ColumnKeys<'bldr>> {
            let mut builder = ColumnKeysBuilder::new(_fbb);
            if let Some(x) = args.column_keys {
                builder.add_column_keys(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn column_keys(&self) -> Option<&'a [ColumnKey]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ColumnKey>>>(
                    ColumnKeys::VT_COLUMN_KEYS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for ColumnKeys<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ColumnKey>>>(
                    "column_keys",
                    Self::VT_COLUMN_KEYS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ColumnKeysArgs<'a> {
        pub column_keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ColumnKey>>>,
    }
    impl<'a> Default for ColumnKeysArgs<'a> {
        #[inline]
        fn default() -> Self {
            ColumnKeysArgs { column_keys: None }
        }
    }

    pub struct ColumnKeysBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ColumnKeysBuilder<'a, 'b> {
        #[inline]
        pub fn add_column_keys(&mut self, column_keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ColumnKey>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnKeys::VT_COLUMN_KEYS, column_keys);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColumnKeysBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ColumnKeysBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ColumnKeys<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ColumnKeys<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ColumnKeys");
            ds.field("column_keys", &self.column_keys());
            ds.finish()
        }
    }
    pub enum ColumnKeysWithRangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ColumnKeysWithRange<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ColumnKeysWithRange<'a> {
        type Inner = ColumnKeysWithRange<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ColumnKeysWithRange<'a> {
        pub const VT_COLUMN_KEYS: flatbuffers::VOffsetT = 4;
        pub const VT_MIN: flatbuffers::VOffsetT = 6;
        pub const VT_MAX: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.ColumnKeysWithRange"
        }

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ColumnKeysWithRange { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ColumnKeysWithRangeArgs<'args>,
        ) -> flatbuffers::WIPOffset<ColumnKeysWithRange<'bldr>> {
            let mut builder = ColumnKeysWithRangeBuilder::new(_fbb);
            builder.add_max(args.max);
            builder.add_min(args.min);
            if let Some(x) = args.column_keys {
                builder.add_column_keys(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn column_keys(&self) -> Option<&'a [ColumnKey]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ColumnKey>>>(
                    ColumnKeysWithRange::VT_COLUMN_KEYS,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn min(&self) -> i64 {
            self._tab.get::<i64>(ColumnKeysWithRange::VT_MIN, Some(0)).unwrap()
        }
        #[inline]
        pub fn max(&self) -> i64 {
            self._tab.get::<i64>(ColumnKeysWithRange::VT_MAX, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for ColumnKeysWithRange<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ColumnKey>>>(
                    "column_keys",
                    Self::VT_COLUMN_KEYS,
                    false,
                )?
                .visit_field::<i64>("min", Self::VT_MIN, false)?
                .visit_field::<i64>("max", Self::VT_MAX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ColumnKeysWithRangeArgs<'a> {
        pub column_keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ColumnKey>>>,
        pub min: i64,
        pub max: i64,
    }
    impl<'a> Default for ColumnKeysWithRangeArgs<'a> {
        #[inline]
        fn default() -> Self {
            ColumnKeysWithRangeArgs {
                column_keys: None,
                min: 0,
                max: 0,
            }
        }
    }

    pub struct ColumnKeysWithRangeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ColumnKeysWithRangeBuilder<'a, 'b> {
        #[inline]
        pub fn add_column_keys(&mut self, column_keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ColumnKey>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnKeysWithRange::VT_COLUMN_KEYS, column_keys);
        }
        #[inline]
        pub fn add_min(&mut self, min: i64) {
            self.fbb_.push_slot::<i64>(ColumnKeysWithRange::VT_MIN, min, 0);
        }
        #[inline]
        pub fn add_max(&mut self, max: i64) {
            self.fbb_.push_slot::<i64>(ColumnKeysWithRange::VT_MAX, max, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColumnKeysWithRangeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ColumnKeysWithRangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ColumnKeysWithRange<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ColumnKeysWithRange<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ColumnKeysWithRange");
            ds.field("column_keys", &self.column_keys());
            ds.field("min", &self.min());
            ds.field("max", &self.max());
            ds.finish()
        }
    }
} // pub mod models
